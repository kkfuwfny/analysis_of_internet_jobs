#-*- coding: utf-8 -*-
#这个版本实现一部分功能，下个版本将实现分句来决定课程
import jobDB
import re
import time
from mainNlpir import *   #分词程序
from bloomFilter import bloomfilter
if __name__ == '__main__':
    
    """从那些不是开头就匹配出的课程中找出重复的课程。例如：关键词是’测试‘ ，匹配到软件测试"""
    bf_get_repeat_courses = bloomfilter.BloomFilter('./bloomFilter/repeatCoursesHash.txt',True) 
    job_db = jobDB.jobDB()
    #ImportUserDict('./userDict/userDict.txt')
    for i in range(1,10):
        bf_remain = bloomfilter.BloomFilter('./bloomFilter/singleCourseHash.txt',True)  #过滤多余的
        res = job_db.queryDescription(i)
        #resn = res.encode('utf-8')
        #print type(resn)
        print '-----------------------------------'
        des = res[0].encode('utf-8')
        print 'des = ',des
        course_file = open('courses/courses.txt','r+')
        courses = course_file.readlines()
        course_set=[]
        for cou in courses:
            #print cou.strip('\n')
            job_course1 = re.findall('(.*?)=',cou.strip('\n'))
            #if re.search(job_course1[0],des) != None:
            if re.search(job_course1[0],des,re.I) != None:
                #print cou.strip('\n')
                #print 'jc[0]=',job_course1[0]
                job_course2 = re.findall('=(.*?)$',cou.strip('\n'))
                if bf_remain.isContaions(job_course2[0]) == False:
                    bf_remain.insert(job_course2[0])
                    print 'course=',job_course2[0]

        print '-----------------------------------'
        print '-----------------------------------'
        #print 'jc[1]=',job_course2[0]
    #在描述中每一个要求都是用‘;’或者'。'结尾的。
    #section = re.findall("(.*?)(。|；)",des)
    #string = WordFreqStat(des)
    #spiltRes = re.findall('(.*?)\#',string)
    #for sp in spiltRes:      #找出名词和动词
    #    sr = re.findall('(.*?)/(n|v.*?)/(\d?)',sp)
    #    for s in sr:
    #        #print s[0] + "/" + s[1] + "/" + s[2]
    #       # print 's[0] = ',s[0]
    #        wordFreq.append(s[0])
    #course = job_db.queryCourses()
   #     courseFreq.append(cou[0].encode('utf-8') + ';')
   # #ms =  "(.*?)" +cou[0].encode('utf-8')+ "(.*?);"
   # count = 1
   # for cou in courseFreq:
   #     print 'course%d='%count + cou
   #     count += 1
               #for ww in wordFreq:
    #    print 'ww = ',ww
    #    tempWw = tempWw + ww + ';'
    print "---------------------------"
    print "---------------------------"
     

    #wf = ''
    #for ww in wordFreq:
    #    #print 'ww = ' ,ww
    #    wf = wf + ww +';'
    #    ms = "(.*?)" + ww + "(.*?);"
    #    print 'ms = ',ms
    #    for cf in courseFreq:
    #        cc = re.findall(ms,cf,re.I)
    #        for pc in cc:
    #            print 'ww = ',ww
    #            mertPc =  ww +pc[1]  
    #            print 'mertPc = ',mertPc
    #                bf.insert(str(mertPc))
    #                ref_course = ref_course + mertPc  + ";"
 #   for sec in section:
 #       wf = ''
 #       print 'se c=',sec[0]
 #       sec_spilt = WordFreqStat(sec[0])
 #       spiltRes = re.findall('(.*?)\#',sec_spilt)
 #       for sp in spiltRes:
 #           sRes = re.findall('(.*?)/(n|v.*?)/(\d?)',sp)
 #           for s in sRes:
##                print s[0] + "/" + s[1] + "/" + s[2]
##                print 's[0] = ',s[0]
 #               wf = wf + s[0] +';'
 #               wordFreq.append(s[0]) 
 #               
 #           #print 'ww = ' ,ww
 #               #ms = "(.*?)" + s[0] + "(.*?);"
 #               ms = "\A" + s[0] + "(.*?);"
 #               print 'ms = ',ms
 #               for cf in courseFreq:
 #                   cc = re.findall(ms,cf,re.I)
 #                   for pc in cc:
 #                       mertPc = ''
 #                       print 's[0]=',s[0]
 #                       mertPc = s[0] + pc
 #                       print 'mertPc=',mertPc
 #                       if bf_remain.isContaions(str(mertPc)) == False  :
 #                           bf_remain.insert(str(mertPc))
 #                           ref_course = ref_course + mertPc  + ";"
 #                           break     #只匹配一次，防止像‘java' 匹配到java javaee 这样的情况出现。javaee课程名字应该放在java后面
